name: Shared Spacelift Branch Reset

on:
  workflow_call:
    inputs:
      spacelift_endpoint:
        description: 'The Spacelift instance URL (e.g., https://nelsong6.app.us.spacelift.io)'
        required: true
        type: string
        default: 'https://nelsong6.app.us.spacelift.io'
      target_branch:
        description: 'The branch to reset the stack to'
        required: false
        type: string
        default: 'main'
      azure_client_id:
        description: 'Azure Client ID (OIDC)'
        required: false
        type: string
        default: '043b35c3-f5de-4578-acd2-8b8f4c78f461'
      azure_tenant_id:
        description: 'Azure Tenant ID'
        required: false
        type: string
        default: '2236b5e4-81d2-4d82-bde5-17b1037999ea'
      azure_subscription_id:
        description: 'Azure Subscription ID'
        required: false
        type: string
        default: 'aee0cbd2-8074-4001-b610-0f8edb4eaa3c'

  workflow_dispatch:
    inputs:
      spacelift_endpoint:
        description: 'The Spacelift instance URL'
        required: true
        type: string
        default: 'https://nelsong6.app.us.spacelift.io'
      target_branch:
        description: 'The branch to reset the stack to'
        required: false
        type: string
        default: 'main'
      azure_client_id:
        description: 'Azure Client ID (OIDC)'
        required: false
        type: string
        default: '043b35c3-f5de-4578-acd2-8b8f4c78f461'
      azure_tenant_id:
        description: 'Azure Tenant ID'
        required: false
        type: string
        default: '2236b5e4-81d2-4d82-bde5-17b1037999ea'
      azure_subscription_id:
        description: 'Azure Subscription ID'
        required: false
        type: string
        default: 'aee0cbd2-8074-4001-b610-0f8edb4eaa3c'

permissions:
  id-token: write
  contents: read

jobs:
  reset-branch:
    name: Reset Spacelift Tracked Branch
    runs-on: ubuntu-latest
    steps:
      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ inputs.azure_client_id }}
          tenant-id: ${{ inputs.azure_tenant_id }}
          subscription-id: ${{ inputs.azure_subscription_id }}

      - name: Fetch Spacelift Credentials from Key Vault
        run: |
          set -euo pipefail
          
          RAW_ID=$(az keyvault secret show --vault-name "${{ vars.AZURE_KEY_VAULT_NAME }}" --name spacelift-api-key-id --query value -o tsv)
          KV_ID=$(echo "$RAW_ID" | tr -d '\r\n')
          echo "::add-mask::$KV_ID"
          echo "SPACELIFT_API_KEY_ID=$KV_ID" >> $GITHUB_ENV

          RAW_SECRET=$(az keyvault secret show --vault-name "${{ vars.AZURE_KEY_VAULT_NAME }}" --name spacelift-api-key-secret --query value -o tsv)
          KV_SECRET=$(echo "$RAW_SECRET" | tr -d '\r\n')
          echo "::add-mask::$KV_SECRET"
          echo "SPACELIFT_API_KEY_SECRET=$KV_SECRET" >> $GITHUB_ENV

      - name: Setup Spacelift CLI (spacectl)
        uses: spacelift-io/setup-spacectl@v1

      - name: Update Stack Branch
        id: update_branch
        env:
          SPACELIFT_API_KEY_ENDPOINT: ${{ inputs.spacelift_endpoint }}
          SPACELIFT_STACK_ID: ${{ github.event.repository.name }}
          TARGET_BRANCH: ${{ inputs.target_branch }}
        run: |
          echo "Targeting Spacelift stack: $SPACELIFT_STACK_ID"
          
          node -e '
            const fs = require("fs");
            async function run() {
              const endpoint = process.env.SPACELIFT_API_KEY_ENDPOINT + "/graphql";
              const headers = { "Content-Type": "application/json" };
              const id = process.env.SPACELIFT_API_KEY_ID.trim();
              const secret = process.env.SPACELIFT_API_KEY_SECRET.trim();

              // 1. Authenticate via GraphQL
              const authRes = await fetch(endpoint, {
                method: "POST", headers,
                body: JSON.stringify({
                  query: `mutation($id: ID!, $secret: String!) { apiKeyUser(id: $id, secret: $secret) { jwt } }`,
                  variables: { id, secret }
                })
              }).then(r => r.json());
              
              if (authRes.errors) throw new Error("Auth errors: " + JSON.stringify(authRes.errors));
              headers["Authorization"] = `Bearer ${authRes.data.apiKeyUser.jwt}`;

              // 2. Fetch current stack state
              const getStack = await fetch(endpoint, {
                method: "POST", headers,
                body: JSON.stringify({
                  query: `query($id: ID!) { stack(id: $id) { name repository branch administrative autodeploy autoretry description projectRoot space labels workerPool { id } vendorConfig { __typename ... on StackConfigVendorTerraform { version workspace workflowTool } } } }`,
                  variables: { id: process.env.SPACELIFT_STACK_ID }
                })
              }).then(r => r.json());

              if (!getStack.data || !getStack.data.stack) throw new Error("Fetch stack failed: " + JSON.stringify(getStack));
              const stack = getStack.data.stack;
              
              // EARLY EXIT: If the branch is already correct, flag it and skip the mutation
              if (stack.branch === process.env.TARGET_BRANCH) {
                console.log(`✅ Stack "${stack.name}" is already tracking branch "${stack.branch}". Skipping update and deployment.`);
                fs.appendFileSync(process.env.GITHUB_OUTPUT, "changed=false\n");
                return;
              }

              console.log(`Resetting tracked branch from "${stack.branch}" to "${process.env.TARGET_BRANCH}" via GraphQL API...`);

              // 3. Construct StackInput perfectly mapping the existing state
              const input = {
                name: stack.name,
                repository: stack.repository,
                branch: process.env.TARGET_BRANCH,
                administrative: stack.administrative,
                autodeploy: stack.autodeploy,
                autoretry: stack.autoretry,
                description: stack.description,
                projectRoot: stack.projectRoot,
                space: stack.space,
                labels: stack.labels || [],
                workerPool: stack.workerPool ? stack.workerPool.id : null,
                vendorConfig: {}
              };

              if (stack.vendorConfig && stack.vendorConfig.__typename === "StackConfigVendorTerraform") {
                input.vendorConfig.terraform = {
                  version: stack.vendorConfig.version,
                  workspace: stack.vendorConfig.workspace,
                  workflowTool: stack.vendorConfig.workflowTool
                };
              }

              // 4. Send GraphQL Mutation
              const updateRes = await fetch(endpoint, {
                method: "POST", headers,
                body: JSON.stringify({
                  query: `mutation($id: ID!, $input: StackInput!) { stackUpdate(id: $id, input: $input) { id branch } }`,
                  variables: { id: process.env.SPACELIFT_STACK_ID, input }
                })
              }).then(r => r.json());

              if (updateRes.errors) throw new Error("Update failed: " + JSON.stringify(updateRes.errors));
              console.log("✅ Stack branch successfully updated to: " + updateRes.data.stackUpdate.branch);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, "changed=true\n");
            }
            run().catch(e => { console.error(e.message); process.exit(1); });
          '

      - name: Trigger Deployment
        if: steps.update_branch.outputs.changed == 'true'
        env:
          SPACELIFT_API_KEY_ENDPOINT: ${{ inputs.spacelift_endpoint }}
          SPACELIFT_STACK_ID: ${{ github.event.repository.name }}
          TARGET_BRANCH: ${{ inputs.target_branch }}
        run: |
          echo "Triggering deployment on $TARGET_BRANCH..."
          spacectl stack deploy --id "$SPACELIFT_STACK_ID"
          echo "✅ Deployment triggered successfully."
